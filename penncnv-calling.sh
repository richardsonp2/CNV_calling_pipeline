#!/bin/bash
#
# An implementation of PsyMed/10/SOP122/v1.1, section 6.4 onwards using
# the PennCNV software to call CNVs in data 
# generated by Illumina iScan array genotyping. Much of this is built on scripts by Ellis Piers
#
#SBATCH --job-name=penncnvcalling
#SBATCH --account=scw1354
#SBATCH --partition=c_compute_neuro1
#SBATCH --time=00-12:00:00
#SBATCH --mem-per-cpu=10G
#SBATCH --cpus-per-task 4
#SBATCH --output=logs/o.%J
#SBATCH --error=logs/e.%J
#
set -euo pipefail  # Exit on error, undefined variables, and pipe failures

## Load Configuration 
# 
CONFIG_FILE="${5:-penncnv_config.yaml}"
if [ ! -f "$CONFIG_FILE" ]; then
    echo "ERROR: Config file not found: $CONFIG_FILE" >&2
    exit 1
fi

SCRIPT_DIR="$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" && pwd)"

# Gather input files
PENN_CNV_FILES_DIR="${SCRIPT_DIR}/penn_cnv_files"


INPUT_FILE=$1
PFB_FILE=("$PENN_CNV_FILES_DIR"/*.pfb)
GCM_FILE=("$PENN_CNV_FILES_DIR"/*.gcmodel)
MASTER_LIST=("$PENN_CNV_FILES_DIR"/*.txt)


# check input first
if [ ! -f "$INPUT_FILE" ]; then
    echo "ERROR: Required file not found: $INPUT_FILE" >&2
    exit 1
fi

# check pfb
if [ ${#PFB_FILE[@]} -eq 0 ]; then
    echo "ERROR: No .pfb files found in $PENN_CNV_FILES_DIR" >&2
    exit 1
fi

# check gcmodel
if [ ${#GCM_FILE[@]} -eq 0 ]; then
    echo "ERROR: No .gcmodel files found in $PENN_CNV_FILES_DIR" >&2
    exit 1
fi

# check txt master list
if [ ${#MASTER_LIST[@]} -eq 0 ]; then
    echo "ERROR: No .txt master list found in $PENN_CNV_FILES_DIR" >&2
    exit 1
fi

# Derive sample prefix
SAMPLE_PREFIX=$(basename "$INPUT_FILE" | sed 's/\(.*\)\..*/\1/')

SCRATCH_BASE="/scratch/${USER}"

#If scratch does not exist, eg using local for testing, set up tmp folder structure. 
if [ ! -d "$SCRATCH_BASE" ]; then 
  echo "/scratch not found using temp local dir instead!"
  SCRATCH_BASE="$(pwd)/tmp_scratch"
  mkdir -p "$SCRATCH_BASE"
fi


BASE_DIR="${SCRATCH_BASE}/${SAMPLE_PREFIX}"
OUTPUT_DIR="${BASE_DIR}/output"
RAW_CNVS_DIR="${OUTPUT_DIR}/raw_cnvs"
LOGS_DIR="${OUTPUT_DIR}/logs"



mkdir -p "$RAW_CNVS_DIR" "$LOGS_DIR"
## Accessing PennCNV and associated files
#

# This is to allow this script to run on local and HPC
if command -v module >/dev/null 2>&1; then
    module load penncnv || true
    module load R || true
    module load anaconda
    module load python
else
    # fallback: local installs
    export PATH="$HOME/penncnv:$PATH"
    export PATH="$HOME/miniconda3/bin:$PATH"   # or wherever your R is
fi

eval $(python3 parse_config.py "$CONFIG_FILE")

## Setup Logging
#
# Create main log file
#mkdir -p "${OUTPUT_DIR}/${CFG_DIRECTORIES_LOGS}"
MAIN_LOG="${LOGS_DIR}/${SAMPLE_PREFIX}_pipeline.log"
PENNCNV_LOG="${LOGS_DIR}/${SAMPLE_PREFIX}_penncnv.log"
RAW_CNV_OUT="${RAW_CNVS_DIR}/${SAMPLE_PREFIX}.rawcnv"



log_message() {
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] $1" | tee -a "$MAIN_LOG"
}

log_error() {
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] ERROR: $1" | tee -a "$MAIN_LOG" >&2
}

log_message "=============================="
log_message "=============================="
log_message "=== Starting PennCNV Pipeline for ${SAMPLE_PREFIX} ==="
log_message "Input file: $INPUT_FILE"
log_message "PFB file: $PFB_FILE"
log_message "GCM file: $GCM_FILE"
log_message "Master list: $MASTER_LIST"
log_message "Config file: $CONFIG_FILE"


## Splitting the Files
#
log_message "Step 1: Splitting input files"
echo "OUTPUT_DIR IS: ${OUTPUT_DIR}"
mkdir -p "${OUTPUT_DIR}"
SPLIT_FILES_DIR="${OUTPUT_DIR}/split_files"
echo "SPLIT_FILES_DIR IS: ${SPLIT_FILES_DIR}"
mkdir -p "${SPLIT_FILES_DIR}"
rm -rf "${SPLIT_FILES_DIR}/${SAMPLE_PREFIX}."*

if ! kcolumn.pl \
  "$INPUT_FILE" \
  split 3 \
  -heading 3 \
  -name_by_header \
  -tab \
  -output "${SPLIT_FILES_DIR}/${SAMPLE_PREFIX}"; then 
  log_error "File splitting failed"
  exit 1 
fi


## Calling Raw CNVs
#
log_message "Step 2: Detecting raw CNVs..."

RAW_CNVS_DIR="${OUTPUT_DIR}/raw_cnvs"
mkdir -p "${RAW_CNVS_DIR}"
rm -rf "logs/${SAMPLE_PREFIX}.rawcnv.log"

HMM_FILE="$(dirname `which detect_cnv.pl`)/lib/hhall.hmm"


#SCRIPT_DIR=$PWD
cd "$BASE_DIR"

echo "${LOGS_DIR}/${SAMPLE_PREFIX}"

detect_cnv.pl \
  -test \
  -confidence \
  -hmm ${HMM_FILE} \
  -pfb ${PFB_FILE} \
  -gcmodel ${GCM_FILE} \
  -log "$PENNCNV_LOG" \
  "${SPLIT_FILES_DIR}/${SAMPLE_PREFIX}."* \
  -output "$RAW_CNV_OUT" \
  >>"$PENNCNV_LOG" 2>&1 



cd $SCRIPT_DIR
log_message "Raw CNV detection complete"

## Merging Raw CNVs
#
log_message "Step 3: Cleaning and merging CNVs..."

CLEAN_CNVS_DIR="${OUTPUT_DIR}/clean_cnvs"
mkdir -p "${CLEAN_CNVS_DIR}"

clean_cnv.pl \
  combineseg "${RAW_CNVS_DIR}/${SAMPLE_PREFIX}.rawcnv" \
  -bp -signalfile ${PFB_FILE} \
  -output "${CLEAN_CNVS_DIR}/${SAMPLE_PREFIX}.clean.rawcnv"

log_message "Cleaning and merging CNV complete"

## Sample Level And Call Level Quality Control
#
log_message "Step 4: Applying quality control filters..."

QC_CNVS_DIR="${OUTPUT_DIR}/qc_cnvs"
mkdir -p "${QC_CNVS_DIR}"

filter_cnv.pl \
  "${CLEAN_CNVS_DIR}/${SAMPLE_PREFIX}.clean.rawcnv" \
  -numsnp 10 \
  -length 100k \
  -qclrrsd 0.3 \
  -qclogfile "logs/${SAMPLE_PREFIX}.rawcnv.log" \
  -qcpassout "${QC_CNVS_DIR}/${SAMPLE_PREFIX}.qcpass" \
  -qcsumout "${QC_CNVS_DIR}/${SAMPLE_PREFIX}.qcsum" \
  -output "${QC_CNVS_DIR}/${SAMPLE_PREFIX}.goodcnv"

log_message "Quality control complete"


# The rest of this is python stuff and plotting. Can restore this later, but for now lets use R?

: '
## Overlapping and novel good CNVs
#
log_message "Step 5: Identifying overlapping and novel CNVs..."

OVERLAP_DIR="${OUTPUT_DIR}/overlap_novel"
mkdir -p "$OVERLAP_DIR"

conda activate penncnvcalling

if ! python identify_overlaps.py \
  "$MASTER_LIST" \
  "${QC_CNVS_DIR}/${SAMPLE_PREFIX}.goodcnv" \
  "$SAMPLE_PREFIX" \
  "$OVERLAP_DIR"; then
    log_error "Overlap identification failed"
    exit 1
fi


## Plot All Called CNVs In A Sample Set
#

PLOTS_DIR="${OUTPUT_DIR}/plots"
ALL_PLOTS_DIR="${PLOTS_DIR}/all"
NOVEL_PLOTS_DIR="${PLOTS_DIR}/novel"
OVERLAP_PLOTS_DIR="${PLOTS_DIR}/overlap"

mkdir -p "${PLOTS_DIR}"
mkdir -p "${ALL_PLOTS_DIR}"
mkdir -p "${NOVEL_PLOTS_DIR}"
mkdir -p "${OVERLAP_PLOTS_DIR}"
rm -rf "${ALL_PLOTS_DIR}/"*
rm -rf "${NOVEL_PLOTS_DIR}/"*
rm -rf "${OVERLAP_PLOTS_DIR}/"*

cd $SPLIT_FILES_DIR

for SAMPLE in $(ls -1)
do
  visualize_cnv.pl \
    -format plot -signal "$SAMPLE" \
    "${QC_CNVS_DIR}/${SAMPLE_PREFIX}.goodcnv"
done
mv *".JPG" $ALL_PLOTS_DIR

for SAMPLE in $(ls -1)
do
  visualize_cnv.pl \
    -format plot -signal "$SAMPLE" \
    "${OVERLAP_DIR}/${SAMPLE_PREFIX}.novel.cnv"
done
mv *".JPG" $NOVEL_PLOTS_DIR

for SAMPLE in $(ls -1)
do
  visualize_cnv.pl \
    -format plot -signal "$SAMPLE" \
    "${OVERLAP_DIR}/${SAMPLE_PREFIX}.overlap.cnv"
done
mv *".JPG" $OVERLAP_PLOTS_DIR

cd $SCRIPT_DIR


## Separate files by service user
#

python sort_service_users_cnvs.py \
  "${RAW_CNVS_DIR}/${SAMPLE_PREFIX}.rawcnv" \
  "${RAW_CNVS_DIR}" \
  "${SAMPLE_PREFIX}" \
  "rawcnv"

python sort_service_users_cnvs.py \
  "${CLEAN_CNVS_DIR}/${SAMPLE_PREFIX}.clean.rawcnv" \
  "${CLEAN_CNVS_DIR}" \
  "${SAMPLE_PREFIX}" \
  "clean.rawcnv"

python sort_service_users_cnvs.py \
  "${QC_CNVS_DIR}/${SAMPLE_PREFIX}.goodcnv" \
  "${QC_CNVS_DIR}" \
  "${SAMPLE_PREFIX}" \
  "goodcnv"

python sort_service_users_cnvs.py \
  "${OVERLAP_DIR}/${SAMPLE_PREFIX}.novel.cnv" \
  "${OVERLAP_DIR}" \
  "${SAMPLE_PREFIX}" \
  "novel.cnv"

python sort_service_users_cnvs.py \
  "${OVERLAP_DIR}/${SAMPLE_PREFIX}.overlap.cnv" \
  "${OVERLAP_DIR}" \
  "${SAMPLE_PREFIX}" \
  "overlap.cnv"

/bin/bash ./sort_service_users_files.sh $SPLIT_FILES_DIR
/bin/bash ./sort_service_users_files.sh $ALL_PLOTS_DIR
/bin/bash ./sort_service_users_files.sh $NOVEL_PLOTS_DIR
/bin/bash ./sort_service_users_files.sh $OVERLAP_PLOTS_DIR

'